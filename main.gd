
extends Node3D

@onready var window: Window = get_window()
@onready var player: Player = get_tree().get_first_node_in_group('Players')

@onready var ingredient = preload("res://objects/ingredient.tscn")

var spawn_timer = Timer.new()
var RANGE = 12.0
var MAX = 25.0

# GOAL:
# Create the potion out of the asked for ingredients

# DO: 
# - Push the desired ingredients in
# - Push the scary ingredients in
# - Dodge the traps
# - Portals appear on the 4 walls, at increments. 
# - Use Portals to disappear bad ingredients or hazards
# - Portals are how you get rid of unwanted enemies AND unwanted ingredients

# DO NOT: 
# - allow too many oopsies (bad ingredients)
# - run out of time to make the potions

@onready var required_item = preload("res://objects/required_item.tscn")

var current_ingredients: = []

func start_game():
	%MainMusic.play()
	$BubbleNoise.play()
	$PlayerUI.show()
	$Valtestscene.cam()
	
	%CauldronArea.set_collision_mask_value(8, true)
	%CauldronArea.body_entered.connect(on_collect)
	%Kill.body_entered.connect(on_collect_kill)

	await get_tree().create_timer(3).timeout
	%LabelStart.text = "GET READY"
	%LabelStart.show()
	print("INFO: GAME LOADED")
	await get_tree().create_timer(3).timeout
	%LabelStart.text = "START"
	%LabelStart.show()
	print("INFO: START! (this should be a label / message)" )
	await get_tree().create_timer(3).timeout
	seed_potions_requirements()

	print("INFO: ROUND STARTED")
	await get_tree().create_timer(3).timeout
	%LabelStart.hide()
	%RoundTimer.wait_time = 60.0
	%RoundTimer.timeout.connect(on_round_timer_end)
	%RoundTimer.start()
	
	spawn_timer.wait_time = 1.0
	spawn_timer.one_shot = true
	spawn_timer.timeout.connect(spawn_ingredient)
	add_child(spawn_timer)
	spawn_timer.start()
	
var levels: Array[Array] = [
	[0, 2, 0, 0, randi_range(1, 2)], 
	[1, randi_range(1, 2), randi_range(0, 2), 0, 1], 
	[2, 0, 2, 2, 1]
]

var level_difficulty = [12, 17, 25] # higher upper bounds make more skulls
var level_amounts = [0, 2, 5] # ingredient multiplyer 

var current_level := 0
var current_round := 0

func seed_potions_requirements():
	for round_item in levels[current_level]:
		var new_required: RequiredItem = required_item.instantiate()
		new_required.set_required(round_item)
		%RequiredList.add_child(new_required, true)
	
	await get_tree().create_timer(1).timeout
	%RequiredList.get_child(current_round).active = true
	if current_level > 0:
		%RoundTimer.wait_time = 32
	elif current_level > 1:
		%RoundTimer.wait_time = 28
	%RoundTimer.start()


func _process(_delta):
	%LabelTimeRemaining.text = str("%.1f" % %RoundTimer.time_left)	

func on_collect_kill(body):
	if body.is_in_group("Ingredients"):
		var collected: Ingredient = body
		collected.queue_free()

func on_collect(body):
	if body.is_in_group("Ingredients"):
		var collected: Ingredient = body
		current_ingredients.append(collected.type)
		if collected.type == Ingredient.TYPE.SKULL and not %RoundTimer.is_stopped():
			splash_hurt()
			if %Hearts.get_child_count() == 1:
				game_over()
				%Hearts.get_child(0).queue_free()
			else:
				print('ouch: ', %Hearts.get_child_count())
				%Hearts.get_child(0).queue_free()
			collected.queue_free()
			return
			
		var desired: bool = collected.type == get_current_primary()
		splash(desired)
	
		collected.queue_free()

func splash(desired):
	var rand = randi_range(0, 1)
	if rand == 0:
		$Splash1.play()
	else:
		$Splash2.play()
	if desired == true:
		await get_tree().create_timer(0.5).timeout
		$Good.play()		

func splash_hurt():
	var rand = randi_range(0, 1)
	if rand == 0:
		$Splash1.play()
	else:
		$Splash2.play()
	await get_tree().create_timer(0.5).timeout
	$Hurt.play()	


var total_complete = 0

# look into the array generated by seed for judgements.
func on_round_timer_end():
	var round_item: RequiredItem = %RequiredList.get_child(current_round)
	var desired_count = current_ingredients.count(get_current_primary())
	if desired_count >= 5 + current_level:
		# OK, now make sure we don't have a majority of the non-desired
		var options = [Ingredient.TYPE.MUSHROOM, Ingredient.TYPE.STAR, Ingredient.TYPE.BERRY]
		options.erase(round_item.ingredient_desired)
		if desired_count < current_ingredients.count(options[0]):
			round_item.complete = false
		elif desired_count < current_ingredients.count(options[1]):
			round_item.complete = false
		else:
			round_item.complete = true
			total_complete += 1
	else:
		round_item.complete = false

	print("INFO: ROUND COMPLETED, with: ", round_item.complete, ' LIST: ', current_ingredients)
	%RoundEnd.play()

	if current_round < levels[current_level].size() - 1:
		current_round += 1
		%RequiredList.get_child(current_round).active = true
	elif current_level < 2:
		%RoundTimer.stop()
		current_level += 1
		current_round = 0
		await get_tree().create_timer(3.0).timeout
		%LabelLevel.text = str(current_level + 1)
		for child in %RequiredList.get_children():
			child.queue_free()
		seed_potions_requirements()
	else:
		# you're out of levels, show score
		# Max is 14 (15)
		game_over()

	current_ingredients.clear()


func game_over():
	spawn_timer.stop()
	%RoundTimer.stop()
	%LabelScore.text = str(total_complete + 1)
	%ScoreBoxTop.show()

func get_current_primary(): 
	return levels[current_level][current_round]


func spawn_ingredient():
	if get_tree().get_nodes_in_group("Balls").size() > MAX:
		return
	
	for i in randi_range(2, 4 + current_level):
		await get_tree().create_timer(randf_range(0.2, 0.5)).timeout
		var new_ingredient: Ingredient = ingredient.instantiate()
		var random_radians = randi_range(0, 360)
		new_ingredient.position = get_point_on_circumference(Vector2.ZERO, 16.0, random_radians)
		new_ingredient.initial_angle =  get_point_on_circumference(Vector2.ZERO, 1.0, random_radians - 10)
		new_ingredient.type = get_ingredient_chance(levels[current_level][current_round])
		add_child(new_ingredient, true)
	
	spawn_timer.start(randi_range(7, 12 - current_level))

# TODO: Secret sauce: adjust ratio of incoming ingredients based on current round
func get_ingredient_chance(primary: Ingredient.TYPE, upper_bound = 12) -> Ingredient.TYPE:
	# If good roll, return primary
	var options = [Ingredient.TYPE.MUSHROOM, Ingredient.TYPE.STAR, Ingredient.TYPE.BERRY]
	options.erase(primary)
	
	var roll = randi_range(0, upper_bound + current_level)
	if roll <= 9:
		return primary
	elif roll <= 11:
		return options[randi_range(0, 1)]
	else:
		return Ingredient.TYPE.SKULL

func get_point_on_circumference(center: Vector2, radius: float, angle_radians) -> Vector3:
	var x = center.x + radius * cos(angle_radians)
	var y = center.y + radius * sin(angle_radians)
	return Vector3(x, 8.5, y)
