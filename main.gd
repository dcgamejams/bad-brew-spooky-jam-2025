extends Node3D

@onready var window: Window = get_window()
@onready var player: Player = get_tree().get_first_node_in_group('Players')

# GOAL:
# Create the potion out of the asked for ingredients

# DO: 
# - Push the desired ingredients in
# - Push the scary ingredients in
# - Dodge the traps
# - Portals appear on the 4 walls, at increments. 
# - Use Portals to disappear bad ingredients or hazards
# - Portals are how you get rid of unwanted enemies AND unwanted ingredients

# DO NOT: 
# - allow too many oopsies (bad ingredients)
# - run out of time to make the potions

@onready var required_item = preload("res://objects/PotionIndicator.tscn")

var current_ingredients: = []

func _ready():
	%CauldronArea.set_collision_mask_value(8, true)
	%CauldronArea.body_entered.connect(on_collect)

	await get_tree().create_timer(2).timeout
	seed_potions_requirements()
	await get_tree().create_timer(3).timeout

	%RoundTimer.wait_time = 20
	%RoundTimer.timeout.connect(on_round_timer_end)
	%RoundTimer.start()
	
var leve1 = [0, 0, 1, 0, 1]
var current_round := 0


func seed_potions_requirements():
	for item in leve1:
		var new_required = required_item.instantiate()
		if item == 1:
			new_required.set_required(Ingredient.TYPE.SKULL)
		else:
			new_required.set_required(Ingredient.TYPE.MUSHROOM)

		%RequiredList.add_child(new_required, true)

	# set the first to ready
	%RequiredList.get_child(current_round).active = true


func _process(_delta):
	%LabelTimeRemaining.text = str("%.1f" % %RoundTimer.time_left)	

func on_collect(body):
	if body.is_in_group("Ingredients"):
		var collected: Ingredient = body
		current_ingredients.append(collected.type)
		collected.queue_free()


# look into the array generated by seed for judgements.
func on_round_timer_end():
	if current_ingredients.count(Ingredient.TYPE.MUSHROOM) > 5:
		print('SUCCESS')
	else:
		print('FAIL')
		
	current_ingredients.clear()
	
	current_round += 1
	%RequiredList.get_child(current_round).active = true
	
	# add to UI, good or bad
	
	# Produce potion on last round
